# 📘 Git 训练营实战手册 (Git Training Field Guide)

欢迎加入 **Git 模拟训练中心**。

本环境旨在通过高度还原的真实开发场景，帮你掌握从“入职新手”到“熟练工”级别的 Git 核心技能。你将在这个模拟器中经历代码冲突、紧急修复、历史回溯以及自动化排错等挑战。

## ⚙️ 环境准备 (Setup)

开始之前，请确保你已经完成了初始化：

1. 在终端运行环境重置脚本：
   **Bash**

   ```
   ./init.sh
   ```
2. 进入你的工作目录（后续所有操作默认在此进行）：

   ```
   cd workspace
   ```

> **提示**：根目录下的 `simulator.sh` 是你的“场景模拟器”。在特定任务中，你需要运行它来模拟同事提交代码或制造系统故障。


## 🟢 第一阶段：单兵作战能力 (Survival Basics)

### 任务 1：第一个功能 (The First Feature)

**📜 背景故事**： 你刚刚入职，项目经理分配给你第一个简单的任务：编写一个数学工具模块。虽然代码很简单，但这是验证你 Git 工作流是否规范的第一步。

**🎯 任务目标**：

1. 在 `workspace` 中创建一个名为 `utils.py` 的文件。
2. 在文件中写入一个简单的加法函数 `def add(a, b): return a + b`。
3. 将文件加入暂存区并提交，Message 建议为 `"feat: add basic math utils"`。
4. 建立和远程仓库的链接 `git push --set-upstream origin main`
5. 将代码推送到远程 `main` 分支。

**✅ 验收标准**：使用 `git log` 能看到你的提交；使用 `git status` 确认工作区干净。

### 任务 2：无痕修正 (Cover Your Tracks)

**📜 背景故事**： 刚把任务 1 推送上去，代码审查（Code Review）就来了——你竟然忘了写函数注释（Docstring）！ 如果现在发一个新的 `"fix: add comments"` 提交，会被认为不够专业。你需要悄悄把注释补上，合并到上一次提交中，假装什么都没发生过。

**🎯 任务目标**：

1. 修改 `utils.py`，给函数加上注释。
2. **不要产生新提交**，使用 Amend 技巧将修改合并到上一次提交中。
3. 由于修改了历史，你需要强制推送（Force Push）到远程。

**✅ 验收标准**：`git log` 依然只有一条关于 utils 的提交记录，但文件内容里已经有了注释。

### 任务 3：紧急任务切换 (Context Switching)

**📜 背景故事**： 你正在开发一个复杂的计算功能 `calc.py`，代码写得乱七八糟，甚至还会报错，根本没法提交。 突然，老板冲过来说：“线上 `main.py` 有个文案错误，立刻修好！” 你现在的代码不能丢，也不能提交。你需要先把现场“冷冻”起来。

**🎯 任务目标**：

1. 创建 `calc.py` 并随便写点未完成的代码。
2. 使用 **Stash** 功能暂存当前现场。
3. 修改 `main.py` 的打印内容（模拟修 Bug），提交并推送。
4. 恢复 **Stash** 的内容，继续之前的开发。

**✅ 验收标准**：Bug 已修复提交，且 `calc.py` 的未完成代码回到了工作区。


## 🟡 第二阶段：团队协作与冲突 (Collaboration)

### 任务 4：手慢无 (The Race Condition)

**📜 背景故事**： 你准备提交今天的代码。但在你工作的这段时间里，勤奋的同事“Coworker”已经向远程仓库推送了他的代码。Git 拒绝了你的推送请求。

**⚡ 场景触发**： *(请新开一个终端窗口，在 git-training 根目录运行)*

**Bash**

```
./simulator.sh task4
```

**🎯 任务目标**：

1. 尝试推送你的代码（预期会失败）。(你可以先尝试使用`git fetch`获取远端版本信息）
2. 将远程的变更同步（Pull）到本地。(你需要给`git pull --rebase`强行覆盖
3. 观察并接受同事新增的 `config.py`（如果之前已被覆盖，这里会有合并或更新）。

**✅ 验收标准**：`git log` 中能看到同事的提交记录，且本地代码与远程一致。

### 任务 5：狭路相逢 (Merge Conflict)

**📜 背景故事**： 这是一个经典事故。你觉得 `main.py` 里的问候语不够热情，改成了 "Hello World"。 巧的是，你的同事也觉得不够热情，但他改成了 "Greetings Universe"。 由于你们改了同一行代码，Git 无法自动决定听谁的。

**⚡ 场景触发**：

**Bash**

```
./simulator.sh task5
```

**🎯 任务目标**：

1. 修改 `main.py` 的同一行代码，并进行提交。
2. 尝试 Pull 远程代码，触发 **Conflict**。
3. 打开 `main.py`，手动解决冲突（保留你的、他的，或合并两者）。（你需要使用`git rebase --continue`返回main分支）
4. 标记解决并完成合并提交（Merge Commit）。
5. 推送到远程。

**✅ 验收标准**：`main.py` 中不再包含 `<<<<<<<` 标记，且代码能正常运行。

### 任务 6：历史整容术 (Git Interactive Rebase)

**📜 背景故事**： 你在开发一个大功能时，为了保存进度，连续提交了三次：

* "wip: writing loop"
* "fix: typo"
* "done: finished logic" 这种提交历史如果推送到公共分支会被以此为耻。你需要把它们合并成一个完美的提交。

**🎯 任务目标**：

1. 在本地连续进行 3 次小修改和提交。
2. 使用交互式变基（Interactive Rebase）处理最近的 3 条记录。
3. 使用 `squash` 将它们合并，并重写 Commit Message 为 `"feat: complete complex logic"`。

**✅ 验收标准**：`git log` 看起来非常整洁，那 3 个啰嗦的提交变成了一个。

你也可以尝试`git reset --soft`直接跳回三个提交（但是保留代码区），重新提交一个完美的结果

## 🟠 第三阶段：版本管理与维护 (Release Engineering)

### 任务 7：里程碑 (Tagging)

**📜 背景故事**： 经过一周的开发，代码终于稳定了。我们要发布 **v1.0** 版本。 你需要给当前的 commit 打上一个永久的标签，以便未来随时能回溯到这个状态。

**🎯 任务目标**：

1. 创建一个附注标签（Annotated Tag）：`v1.0`。
2. 将标签推送到远程（注意：普通的 push 不会推送标签）。

**✅ 验收标准**：在 GitHub能看到 v1.0 标签。

### 任务 8：跨时空修复 (Cherry-Pick)

**📜 背景故事**： v1.0 已经上线。你正在 `main` 分支上开发 v2.0 的新功能。 突然接到报告，v1.0 有个严重 Bug。你在 `main` 分支上修复了这个 Bug（提交 A）。 现在，你需要把**提交 A** 的修复应用到 v1.0 分支上，但**绝不能**把 `main` 上其他未完成的 v2.0 代码带过去。

**🎯 任务目标**：

1. 随便提交点内容作为 v2.0 的开发记录
2. 在 `main` 上提交一个修复，记下它的 Hash。
3. 检出 v1.0 分支（或基于 v1.0 创建 `hotfix/v1.0`）。
4. 使用 Cherry-pick 精准“摘取”那个修复提交。

**✅ 验收标准**：Hotfix 分支上有了修复代码，但没有 `main` 分支的其他新功能。

### 任务 9：谁是罪魁祸首 (Git Blame)

**📜 背景故事**： 代码库里出现了一行奇怪的注释 `"TODO: Refactor this later"`，而且它导致了逻辑隐患。 项目经理很生气，让你找出是谁、在什么时候写的这行代码，以及他当时还改了什么。

**⚡ 场景触发**：

**Bash**

```
./simulator.sh task9
```

**🎯 任务目标**：

1. 更新代码，发现 `main.py` 里的奇怪注释。
2. 使用 `git blame` 定位该行的作者和 Commit Hash。
3. 使用 `git show` 查看该提交的完整详情。

**✅ 验收标准**：成功找出“Coworker”是在哪次提交中引入的问题。


## 🔴 第四阶段：黑魔法与灾难恢复 (Advanced Ops)

### 任务 10：后悔药 (Reflog to the Rescue)

**📜 背景故事**： 这是每个人的噩梦。你原本想撤销一次提交，结果手滑执行了 `git reset --hard HEAD~5`。 一下午的代码全没了！`git log` 里也看不到它们了。 别慌，Git 记得所有事。

**🎯 任务目标**：

1. 先随便做几次提交，丰富一下历史。
2. 执行硬重置，把它们“删掉”。
3. 使用 `git reflog` 查找删除动作之前的 HEAD 指针位置。
4. 使用 `git reset --hard` 跳回到过去，复活代码。

**✅ 验收标准**：那些“丢失”的提交重新回到了 `git log` 中。

### 任务 11：平行宇宙 (Git Worktree)

**📜 背景故事**： 你正在 `main` 分支进行大规模重构，编译文件生成了一堆。 此时需要紧急去修复 `v1.0` 的 Bug。

* 切换分支？会导致重构到一半的文件冲突，且需要重新编译。
* Stash？来回切换太麻烦。
* 重新 Clone？项目太大，下载太慢。 你需要在这个仓库下开启一个“平行空间”。

**🎯 任务目标**：

1. 保持当前 `workspace` 目录不动。
2. 使用 `git worktree` 在上级目录创建一个名为 `workspace-hotfix` 的新文件夹，关联到 `v1.0`。（`git worktree add <address> version`)
3. 去那个新文件夹里修复 Bug。
4. 完成后删除该 Worktree。

**✅ 验收标准**：体验到同时拥有两个不同分支的工作目录。

### 任务 12：全自动捉虫 (Automated Bisect)

**📜 背景故事**： 度假归来，你发现项目跑不起来了（测试失败）。 历史记录显示，你不在的时候同事推了 **100 个版本**。你不知道是哪一个版本引入了 Bug。 手动一个一个试？那要试到天亮。 让 Git 的二分查找算法帮你自动定位吧。

**⚡ 场景触发**： *(⚠️ 警告：此操作会重置整个练习环境)*

**Bash**

```
./simulator.sh task12
```

**🎯 任务目标**：

1. 运行 `python3 test_runner.py`，确认当前最新版本测试失败（Bad）。
2. 启动 `git bisect`。
3. 告诉 Git 当前是 Bad，最开始的版本（或某个旧版本）是 Good。
4. **关键操作**：编写命令让 Git 自动查找：
   **Bash**

   ```
   git bisect run python3 test_runner.py
   ```
5. 坐看终端疯狂滚动。

**✅ 验收标准**：Git 准确输出 `"xxxxxxx is the first bad commit"`（应该是第 66 个版本）。





🎉 **恭喜！** 如果你完成了所有任务，你已经击败了 99% 的 Git 使用者。你可以删除整个 `git-training` 目录，或者保留它作为日后的实验场。
